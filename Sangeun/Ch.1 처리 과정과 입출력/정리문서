Ch.1 SQL 처리 과정과 입출력
2022-04-17(일)
1.1 SQL 파싱과 최적화
옵티마이저가 SQL을 어떻게 처리하는지, 서버 프로세스는 데이터를 어떻게 읽고 저장하는지

1.1.1 구조적 집합적 선언적 질의 언어
원하는 구조 집합을 구조적, 집합적으로 선언, 그 결과집합을 만드는 과정은 절차적임
[사용자-(SQL)-옵티마이저-(실행계획)-프로시저]

DBMS내부에서 프로시저를 작성하고 컴파일해서 실행 가능하도록 만드는 과정 
-> SQL 최적화
   
1.1.2 SQL 최적화 
SQL 파싱 : 파싱 트리 생성 - Syntax 체크(문법) - Semantic 체크(의미)
SQL 최적화 : 옵티마이저가 수행, 미리 수집한 통계정보 바탕으로 실행계획 시뮬레이션데이터 베이스 성능을 좌우하는 핵심엔진
로우 소스 생성 : 프로시저 형태로 포맷팅

1.1.3 SQL 옵티마이저
최적화된 엑세스 경로를 선택해주는 핵심엔진
    1. 실행계획 후보 열거
    2. DD에 존재하는 통계정보 토대로 비용계산
    3. 최저 비용 실행계획 획득

1.1.4 실행 계획과 비용
쿼리 수행 시 발생할 수 있는 입출력 횟수 또는 예상 소요 시간이 비용

1.1.5 옵티마이저 힌트 
실행 계획은 오차 범위 존재, 사용자가 미리 아는 더 빠른 경로를 제시하는 방법 : 힌트
/*+INDEX(A IDX-1) INDEX(B, IDX-2)*/
/*+INDEX(A), INDEX(B)*/ 안됨, 힌트와 힌트 사이에 컴마 노!
FROM절에 별칭 입력 시 반드시 힌트에도 별칭 사용, 안 쓰면 힌트 무효

최적화 목표	ALL_ROWS	전체 처리속도 최적화
	FIRST_ROWS(n)	최초 N건 응답속도 최적화
액세스 방식	FULL	Table full scan 유도
	INDEX	Index scan으로 유도
	INDEX_DESC	인덱스 역순으로 유도
	INDEX_FFS	Fast Full Scan 유도
	INDEX_SS	인덱스 Skip Scan으로 유도
조인순서	ORDERED	From절 순서대로 조인
	LEADING	힌트 기술 순으로 조인
	SWAP_JOIN_INPUT	해시 조인 시 빌드 인풋 명시
조인방식	USE_NL	NL조인으로 유도
	USE_MERGE	소트 머지 조인으로 유도
	USE_HASH	해시 조인으로 유도
	NL_SL	NL 세미조인으로 유도
	MERGE_SJ	머지 세미조인으로 유도
	HASH_SJ	해시 세미조인으로 유도
서브쿼리 팩토링	MATERIALIZE	With문 집합을 물리적으로 생성
	INLINE	With문 집합을 생성하지않고 처리하도록 유도
쿼리변환	MERGE	뷰 머징 유도
	NO_MERGE	뷰 머징 방지
	UNNEST	서브쿼리 unnest 유도
	NO_UNNEST	서브쿼리 unnest 방지
	PUSH_PRED	조인조건 Pushdown 유도
	NO_PUSH_PRED	조인조건 Pushdown 방지
	USE_CONCAT	Or 또는 inlist 조건을 or expansion으로 유도
	NO_EXPAND	Or 또는 inlist 조건을 or expansion으로 방지
병렬 처리	PARALLEL	테이블 스캔 또는 DML 을 봉렬 처리하도록 유도
	PARALLEL_INDEX	인덱스 스캔을 병렬처리
	PQ_DISTRIBUTE	병렬 수행 시 데이터 분배 방식 결정PQ_DISTRIBUTE(T HASH HASH)
기타	APPEND	Direct path insert 로 유도
	DRVING_SITE	Dblink remote 쿼리에 대한 촤적화 및 실행 주체 지정
	PUSH_SUBQ	서브쿼리를 가급적 빨리 필터링하도록 유도
	NO_PUSH_SUBQ	서브쿼리를 가급적 늦게 필터링하도록 유도

1.2 SQL 공유 및 재사용
소프트 파싱과 하드 파싱의 차이

1.2.1 소프트 파싱 vs 하드파싱
라이브러리 캐시 : SQL 최적화 과정을 거쳐 생성된 프로시저를 담아두는 내부 메모리
SGA 구성요소 중 하나(쿼리와 실행계획, 함수/프로시저 등을 저장하는 코드 캐시)

SGA : System Global Area 서버-백그라운드 프로세스가 모두 접근 할 수 있는 데이터와 제어구조를 캐싱하는 메모리 공간

사용자가 쿼리를 입력했을 때 캐시에 남아있어 곧바로 실행 단계로 넘어가면 소프트
없어서 다시 SQL 최적화 단계를 거쳐야 하면 하드 파싱

옵티마이저가 참고하는 정보
    - 테이블, 컬럼, 인덱스 구조에 관한 기본 정보
    - 오브젝트 통계
    - 시스탬 통계
    - 옵타마이저 관련 파라미터

1.3 데이터 저장 구조 및 입출력 매커니즘
데이터 저장구조, 디스크 및 메모리에서 데이터를 읽은 매커니즘
1.3.1 SQL이 느린 이유 - 디스크 입출력 탓
정보를 가져와야 뭘 할 수 있는데, 데이터 입출력하는데 시간이 너무 오래 걸림

1.3.2 데이터베이스 저장 구조
테이블 스페이스> (데이터 파일)=세그먼트(테이블/인덱스/LOB)>익스텐트>블록
*익스텐트는 공간을 확장하는 단위
*실제 데이터가 담기는 공간이 블록, 데이터를 읽고 쓰는 단위
*한 익스텐트는 하나의 테이블이 독점, 공간을 확장하는 단위
*익스텐트 내 블록은 서로 인접한 공간이지만, 연속되진 않음 
*테이블 스페이스는 세그먼트를 담는 컨테이너
*데이터 파일은 디스크 상의 물리적 운영체제 파일

1.3.3 블록 단위 입출력
데이터를 읽고 쓰는 단위가 블록, 특정 레코드만 읽고 싶어도 블록 단위로 읽어야 함

1.3.4 Sequencial 액세스 vs Random 액세스
액세스는 블록을 읽는 방식
논리적 또는 물리적으로 연결된 순서에 따라 차례대로 읽으면 시퀀셜
*세그먼트에 할당된 익스텐트 목록을 세그먼트 헤더에 맵으로 갖고있음
*익스텐트 맵은 각 첫번째 블록의 값을 갖고 있음

논리, 물리 순서에 따르지 않고 레코드 하나를 읽기 위해 한 블록씩 접근하면 랜덤 액세스

1.3.5 논리적 입출력 vs 물리적 입출력
DB 버퍼 캐시 : SGA 구성 요소 중 하나, 데이터 캐시. 같은 블록의 반복 입출력 방지

논리적 입출력 : 쿼리를 처리하는 과정에서 메모리 버퍼 캐시에서 발생한 총 블럭 입출력
물리적 입출력 : 디스크에 발생한 입출력, 버퍼 캐시에서 못 찾았을 경우만 발생하므로 논리적 입출력 > 물리적 입출력

버퍼 캐시 히트율
BCHR = (캐시에서 바로 찾은 블록 수 / 총 읽은 블록 수) * 100
               (논리적 입출력  - 물리적 입출력) / 논리적 입출력 * 100
               (1-물리적 입출력/논리적입출력) * 100

SQL 성능을 높이기 위해선 논리적 입출력을 줄여야 한다!

통계정보에서 
Current +Query = 논리적 입출력(여기이 이미 물리적 입출력이 포함되어있음)
Disk = 물리적 입출력
*근데 버퍼캐시 히트율이 높다고 효율적인 쿼리라는 말은 아님;

1.3.6 Single Block I/O vs. Multiblock I/O
한번에 한 블록씩만 메모리에 적재하는 걸 싱글 블록 입출력
한번이 인접한 여러 블록을 읽어오면 멀티블록 입출력,

보통 인덱스 루트 블록을 읽을 때는 싱글 블록 입출력
읽은 루트 블록을 기준으로 테이블 블록을 읽을 때 멀티 블록

기본 운영체제 입출력 단위가 1MB, 오라클 레벨 입출력 단위가 8KB

1.3.7 Table Full Scan vs. Index Range Scan
전체를 읽을거냐 인덱스 기준으로 일정량만 읽을거냐, 한번에 많은 양을 처리한다면 테이블 풀 스캔이 오히려 더 효율적일 수 있음

Table Full Scan 은 시퀀셜 액세스와 멀티블록 입출력으로 디스크 블록을 읽음
Index Range Scan 랜덤 액세스와 싱글 멀티 블록 사용
*인덱스는 아주 큰 테이블에서 소량의 정보를 빠르게 찾기 위한 용도

1.3.8 캐시 탐색 매커니즘
해시 함수 - 해시 체인 - 버퍼 헤더 - 버퍼 블록
*같은 입력값은 동일한 해시 체인에 연결된다
*다른 입력값이 동일한 해시 체인에 연결될 수 있음
*해시 체인 내 정렬을 보장되지 못함

메모리 공유자원에 대한 액세스 직렬화 = 래치
SGA 구성요소 중 하나인 버퍼 캐시에는 여러 프로세스가 접근할 수 있으므로 직렬화 매커니즘이 필요함
*대량의 데이터를 읽을 때는 모든 버퍼 캐시 체인을 탐색

버퍼 Lock
읽고자 하는 블록을 찾았으면 캐시버퍼 체인 래치를 바로 해제해줘야 다른 프로세스들이 접근 가능, 버퍼 블록 데이터를 읽고 쓰는 과정 중 같은 블록에 접근하면 정합성 문제 발생 가능하므로 버퍼 Lock을 사용
